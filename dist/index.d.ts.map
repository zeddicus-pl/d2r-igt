{"mappings":"AAOA;IACE,OAAO,IAAA;IACP,OAAO,IAAA;IACP,OAAO,IAAA;IACP,OAAO,IAAA;CACR;AAaD,mBAAmB,CAAC,KAAK,EAAE,QAAQ,KAAK,IAAI,CAAC;AAK7C,OAAO,MAAM,8BAA+B,WAAW,SAEtD,CAAA;AAED,OAAO,MAAM,oBAIZ,CAAA;AAED,OAAO,MAAM,mBAEZ,CAAA","sources":["igt.ts"],"sourcesContent":["import { U } from 'zedd-win32-api';\nimport StructDi from 'ref-struct-di';\nimport * as ffi from 'ffi-napi';\nimport * as ref from 'ref-napi';\nimport { DModel as M, DStruct as DS, DTypes as W } from 'win32-def';\nimport { VRect, CaptureScreenshot } from \"windows-ffi\";\n\nexport enum IgtState {\n  UNKNOWN,\n  NO_GAME,\n  PLAYING,\n  LOADING\n}\n\nU.apiDef['SetProcessDPIAware'] = [W.BOOL, []];\nU.apiDef['GetClientRect'] = [W.BOOL, [W.HWND, W.RECT]];\nU.apiDef['ClientToScreen'] = [W.BOOL, [W.HWND, W.LPPOINT]];\nconst user32 = U.load();\nconst Struct = StructDi(ref);\n\nlet igtState = IgtState.UNKNOWN;\nlet hwnd: M.HWND = 0;\nlet tickTime = 500;\nlet timer: NodeJS.Timer;\n\ntype IgtCallback = (state: IgtState) => void;\nlet callback: IgtCallback = (state) => {};\n\nuser32.SetProcessDPIAware();\n\nexport const setIgtCallback = (igtCallback: IgtCallback) => {\n  callback = igtCallback;\n}\n\nexport const startIgt = () => {\n  igtState = IgtState.UNKNOWN;\n  hwnd = 0;\n  timer = setTimeout(tickProcessIgt, tickTime)\n}\n\nexport const stopIgt = () => {\n  clearInterval(timer);\n}\n\nconst runCallbackIfChanged = (state: IgtState) => {\n  if (state != igtState) {\n    igtState = state;\n    callback(igtState);\n  }\n}\n\nconst tickProcessIgt = () => {\n  timer = setTimeout(() => {\n    processIgt();\n    tickProcessIgt();\n  }, tickTime);\n}\n\nconst enumWindowsProc = ffi.Callback(\n  W.BOOL,\n  [W.HWND, W.LPARAM],\n  (window: M.HWND, lParam: M.LPARAM): M.BOOLEAN => {\n    const buf = Buffer.alloc(254)\n    user32.GetWindowTextW(window, buf, buf.byteLength);\n    if (buf.toString('ucs2').replace(/\\0+$/, '') == \"Diablo II: Resurrected\") {\n      hwnd = window;\n      return false;\n    }\n    return true;\n  },\n)\n\nconst noGame = () => {\n  runCallbackIfChanged(IgtState.NO_GAME);\n  hwnd = 0;\n  tickTime = 500;\n}\n\nconst gameLoading = () => {\n  runCallbackIfChanged(IgtState.LOADING);\n  tickTime = 10;\n}\n\nconst gamePlaying = () => {\n  runCallbackIfChanged(IgtState.PLAYING);\n  tickTime = 10;\n}\n\nconst processIgt = () => {\n  if (hwnd === 0) {\n    user32.EnumWindows(enumWindowsProc, 0);\n    if (hwnd === 0) {\n      noGame();\n      return;\n    }\n  }\n\n  /** @ts-ignore */\n  const origin: M.POINT_Struct = new Struct(DS.POINT)();\n  const retw = user32.ClientToScreen(hwnd, origin.ref())\n  if (retw == 0) {\n    noGame();\n    return;\n  }\n  \n  /** @ts-ignore */\n  const rectClient: M.RECT_Struct = new Struct(DS.RECT)();\n  const ret = user32.GetClientRect(hwnd, rectClient.ref())\n  if (ret == 0) {\n    noGame();\n    return;\n  }\n\n  const w = rectClient.right;\n  const h = rectClient.bottom;\n  const x = origin.x;\n  const y = origin.y;\n\n  const screenshot = CaptureScreenshot({\n    rectToCapture: new VRect(x + Math.round(w / 2) - 100, y + h - 1, 200, 1),\n  });\n\n  const isLoading = screenshot.GetPixel(0, 0).ToHex_RGB() == '000000' &&\n    screenshot.GetPixel(100, 0).ToHex_RGB() == '000000' &&\n    screenshot.GetPixel(199, 0).ToHex_RGB() == '000000';\n\n  if (isLoading) {\n    gameLoading();\n  } else {\n    gamePlaying();\n  }\n};\n"],"names":[],"version":3,"file":"index.d.ts.map"}